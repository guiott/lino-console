var parser = require('parser.js');

var exec = require('child_process').exec,
    child;
    
/*-----------------------------------------------------------------------------*/
//Finite State Machine to schedule the HLS data requesting to IMU.
var Indx = 0; // FSM index
exports.imuFsmOn = function(imuPort)
{/* Normal status
	The clock is a 50ms event timer. This is enough time even for a 
	64 byte message packet @19kbps. 
	The navigation parameters (S, K, b & L) are requested and set at the highest 
	5Hz rate. GPS parameters (T & G) are requested alternatively at 0.83Hz. 
	Because the periods of 200ms and 1200ms are all multiple of the 
	50ms clock tick, this allows a whole cycle of 24 ticks where no more 
	than a single receive operation per slot is executed.
  Indx 1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20   21   22   23   24
  ms  000 050 100 150 200 250 300 350 400 450 500 550 600 650 700 750 800 850 900 950 1000 1050 1100 1150 
  cmd  K   b   L   -   K   b   L   T   K   b   L   -   K   b   L   -   K   b   L   G   K    b    L    -  
       S               S               S               S               S               S
*/
	
	Indx ++;
  	//console.log("---"+Indx); //debug
  
	switch (Indx)
	{	
		// every four ticks = 200ms
		case 1:
		case 5:
		case 9:
		case 13:
		case 17:
		case 21:
	  		// set speed & direction HLS -> IMU -> dsNav
      		TxBuff.writeInt16BE(parseInt(DES.vel), (1 + HEADER_LEN));
      		TxBuff.writeInt16BE(parseInt(DES.yaw), (3 + HEADER_LEN));
      		txData('S', 5, imuPort);  
      
      		// GPS & IMU (DCM) parameters GPS-IMU -> HLS
      		txData('K', 1, imuPort);
      		waitForAnswer();
			break;
		
      	// nothing to do. Empty slots
		case 4:
		case 12:
		case 16:
			break;
    
    	// every four ticks = 200ms
		case 3:
		case 7:
		case 11:
		case 15:
		case 19:
		case 23:
      		// values to and from Low Level Supervisor LLS <-> HLS
      		TxBuff.writeUInt8(parseInt(DES.light[0]), (1 + HEADER_LEN));
      		TxBuff.writeUInt8(parseInt(DES.light[1]), (2 + HEADER_LEN));
      		TxBuff.writeUInt8(parseInt(DES.hPwrOff), (3 + HEADER_LEN));      
      
      		txData('L', 4, imuPort);// right now it's simulated by the same serial port but actually it will come from the LLS serial
      		waitForAnswer();
			break;
    
		// every four ticks = 200ms
		case 2:
		case 6:
		case 10: 
		case 14:
		case 18:
		case 22:
			// details on speed, current and position dsNav -> IMU -> HLS	
			txData('b', 1, imuPort);
      		waitForAnswer();
			break;		

		// every 12 ticks = 600ms
		case 8:
			// GPS time parameters GPS -> IMU -> HLS
			txData('T', 1, imuPort);
      		waitForAnswer();
			break;		
		
		// every 12 ticks = 600ms
		case 20:
			// GPS service parameters GPS -> IMU -> HLS	
			txData('G', 1, imuPort);
      		waitForAnswer();
			break;	
		
		default:
			// reset cycle	
			Indx = 0;
			break;						
	}
};

exports.imuFsmOff = function(imuPort)
{/* shutting down status
	The clock is a 25ms event timer.
 */
	
	Indx ++;
  //console.log("---"+Indx); //debug
  
	switch (Indx)
	{	
		// every two ticks = 50ms
		case 1:
		case 3:
		case 5:
		case 7:
      // values to and from Low Level Supervisor LLS <-> HLS
      DES.light[0] = 0;
      DES.light[1] = 0;
      TxBuff.writeUInt8(parseInt(DES.light[0]), (1 + HEADER_LEN));
      TxBuff.writeUInt8(parseInt(DES.light[1]), (2 + HEADER_LEN));
      TxBuff.writeUInt8(parseInt(DES.hPwrOff), (3 + HEADER_LEN));      
      
      txData('L', 4, imuPort);// right now it's simulated by the same serial port but actually it will come from the LLS serial
      waitForAnswer();
			break;
		
    // every four ticks = 50ms
		case 2:
		case 4:
		case 6:
		case 8:
      // set speed & direction HLS -> IMU -> dsNav
      DES.vel = 0x7FFF; // means all wheels stopped
      TxBuff.writeInt16BE(parseInt(DES.vel), (1 + HEADER_LEN));
      TxBuff.writeInt16BE(parseInt(DES.yaw), (3 + HEADER_LEN));

      txData('S', 5, imuPort);    
			break;
    		
		default:
			// reset cycle	
			Indx = 0;
			break;						
	}
};

/*-----------------------------------------------------------------------------*/
WFAflag = 0;
WFAcount = 0;
WFAmax = 10;
WFAtime = 0;
waitForAnswer = function()
{// initialize the counting for no answer at all from peripherals
  WFAflag = 1;  // is waiting
  WFAtime = Date.now(); // start timeout counting
};

answerReceived = function()
{// reset count when full packet received correctly
  WFAflag = 0;  // no more waiting
  WFAcount = 0; // reset timeouts count
  RxStatus = 0;
  Parser();      // decode ready message packet 
};

/*-----------------------------------------------------------------------------*/
var pwrOff = 0;
shutDownProc = function()
{
  DES.hPwrOff = 1;
  LLS.lPwrOff = 1;
  
  if (pwrOff === 0)
  {
    child = exec('echo *****Starting Shutdown Procedure*****', // poweroff',
    //child = exec('poweroff'), // poweroff',
    function (error, stdout, stderr) 
    {
      console.log('stdout: ' + stdout);
      console.log('stderr: ' + stderr);
      if (error !== null) 
      {
        console.log('exec error: ' + error);
      }
      process.nextTick(function() 
      {
        // while(1); // uncomment if you want to stop the program here
      });
    });
  }
  
  pwrOff = 1;
};

/*-----------------------------------------------------------------------------*/
var RX_ID_FLAG  = false;	// command decode flag
var RxPtrStart = 0;       // message packet starting pointer in queue
var RxPtrEnd = 0;         // message packet ending pointer in queue
    RxPtrData = 0;        // pointer to first data in queue

var HEADER = 64;          // header define
var ID = 1;               // this board identification
var RxChkSum = 0;
    HEADER_LEN = 3;       // command string header length (byte)
MAX_BUFF = 256; // buffer size
var TxBuff = new Buffer(MAX_BUFF); // TX buffer 
RxPtrOut = 0;   // outgoing bytes read by Rx function
RxPtrIn = 0;    // circular queue pointer read

txData = function(TxCmd, TxCmdLen, Port)
{// Send the requested parameters, with the correct handshake
    //console.log(ISODateString()+"-----TX Cmd: "+TxCmd); //debug
    var TxChkSum = 0;
    
    TxBuff.writeUInt8(HEADER,0) ;
    TxBuff.writeUInt8(ID,1);       // often not used, useful if many devices on bus
    TxBuff.write(TxCmd,2);         // command
    TxBuff.writeUInt8(TxCmdLen,3); // lenght of the payload plus CHKSUM
    
    for (var i=0; i < TxCmdLen + HEADER_LEN; i++)
    {// compute the checksum
      TxChkSum += TxBuff[i];
    }
   	TxChkSum = TxChkSum % 256; 	// within one byte
    TxBuff.writeUInt8(TxChkSum,i);
    Port.write(TxBuff.slice(0, i+1));
};

/*-----------------------------------------------------------------------------*/
startTime = 0; 
var elapsed;        // to manage timeout
RxCmd=0;

exports.RxData = function (readData)
{// decode each received byte to verify the correctness of the packet
  while ((RxPtrIn != RxPtrOut) && (RxStatus != 99))
  {
    switch (RxStatus)
    {// Finite State Machine driven by the received bytes  
      case 0:	// idle
        if (RxBuff[RxPtrOut] === HEADER)
        {
           startTime = Date.now(); // start timeout counting

           RxStatus = 1;	// header OK -> next status
           RxPtrStart = RxPtrOut;  // queue index for this packet
           RxChkSum = RxChkSum + RxBuff[RxPtrOut];
           RxPtrOut ++;	// byte read -> point to next byte
         }
         else  // no header. out of command sequence -> error
         {
            RxError(2);		   	
         }
         break;

      case 1:	// header received correctly
        if(RxBuff[RxPtrOut]===ID||RxBuff[RxPtrOut]===0)
        {// command addressed to this board or broadcast
               // Id received and recognized
          RX_ID_FLAG = 1;		// it has to decode the command
          RxStatus = 2;		// next FSM status 
        }
        else if (RxBuff[RxPtrOut] === 'z') // special case for manual test of the communication
        {
           RxStatus=99;	// enables command parser 
           RxCmd=RxBuff[RxPtrOut];
           answerReceived();
        }
        else
        {// Id received but NOT recognized 
           RX_ID_FLAG = 0;	// receives but does not decode the command
           RxStatus = 2;		// next FSM status 
        }
        RxChkSum = RxChkSum + RxBuff[RxPtrOut];
        RxPtrOut ++;		// next byte
        break;

      case 2:	// command received
        RxStatus = 3;		// next FSM status
        RxCmd=RxBuff[RxPtrOut];
        RxChkSum = RxChkSum + RxBuff[RxPtrOut];
        RxPtrOut ++;		// next byte
        break;

      case 3:	// command length received
        // calculating end pointer of command string
        cmdLen=RxBuff[RxPtrOut];
        RxPtrEnd=cmdLen+HEADER_LEN+1+RxPtrStart;
        if (RxPtrEnd >= MAX_BUFF)RxPtrEnd -= MAX_BUFF;
        if (RxPtrEnd >= MAX_BUFF)	// still bigger?
        {
           RxError(6);	// queue overflow	
        }
        else
        {
           RxStatus = 4;	     // next FSM status
           RxChkSum = RxChkSum + RxBuff[RxPtrOut];
           RxPtrData=RxPtrOut;// pointer to last header byte, payload after this
           RxPtrOut ++;	     // next byte
        }
        break;

      case 4:	// waiting for command end
        if (RxPtrOut === RxPtrEnd)
         {	
            RxChkSum = RxChkSum % 256; 	// within one byte
            if ((RxChkSum) === (RxBuff[RxPtrOut]))		   	    
              {// checksum OK?
                if (RX_ID_FLAG)	
                {// if right Id -> packet is addressed to me
                  RxStatus=99;// enables command parser 
                  // console.log("Parser enabled - CMD: "+String.fromCharCode(RxCmd)); //debug
                  RxPtrOut ++;	// next byte
                }
                else
                {// flush 
                  RxStatus=0;	// end of command receive 
                  RxPtrOut ++;	// next byte
                }
                answerReceived();
              }
              else
              {
                RxError(5); // checksum error	
              }
              RxChkSum=0;
         }
         else
         {
           RxChkSum = RxChkSum + RxBuff[RxPtrOut];
           RxPtrOut ++;	// next byte
         }
         break;

      default:// error: not a known status
      RxError(7);				   	
      break;
    } // switch end	
    
    if (RxPtrOut >= MAX_BUFF) RxPtrOut=0;//restart circular queue
    // console.log("In:"+RxPtrIn+" Out:"+RxPtrOut+" Stat:"+RxStatus+" Start:"+RxPtrStart+" End:"+RxPtrEnd+" Cmd:"+String.fromCharCode(RxCmd)+" --- "+RxBuff[RxPtrOut]+" "+String.fromCharCode(RxBuff[RxPtrOut])); //debug
  }
};

/*-----------------------------------------------------------------------------*/
RxError = function (Err)
{// manage error status
  switch (Err)
  {
    case 1: // Timeout
      RxErrorText= "Packet not complete. Timeout";
      RxErrorExpected = ' ';
      RxErrorFound = "In="+RxPtrIn+" Out="+RxPtrOut+" Stat="+RxStatus+" Length="+cmdLen+" Start="+RxPtrStart+" End="+RxPtrEnd+" Missing="+(RxPtrEnd-RxPtrOut);
    break;
    
    case 2: // no header found, out of command sequence
      RxErrorText= "No Header";
      RxErrorExpected = '@';
      RxErrorFound = (RxBuff[0]);
    break;
    
    case 3: // unknown command
      RxErrorText= "Wrong CMD";
      RxErrorExpected = 'Cmd';
      RxErrorFound = (RxBuff[2]);
    break;
      
    case 4:
      RxErrorText= "Wrong LEN";
      RxErrorExpected = 'Len';
      RxErrorFound = (RxBuff[3]-1);
    break;

    case 5:
      RxErrorText= "ChkSum err";
      RxErrorExpected = (RxChkSum);
      RxErrorFound = (RxBuff[RxPtrOut]);
    break;

    case 6:
      RxErrorText= "Queue overflow";
      RxErrorExpected = ' ';
      RxErrorFound = ' ';
    break;
    
   case 7:
      RxErrorText= "Unknown FSM status";
      RxErrorExpected = ' ';
      RxErrorFound = RxStatus;
      break;
      
   case 8:
      RxErrorText= "NO ANSWER AT ALL FOR TOO MUCH TIME!";
      RxErrorExpected = "Data";
      RxErrorFound = "SHUTTING DOWN" ;
      shutDownProc(); // Too dangerous! It's better to shut down
      break;
    
    default:
      RxErrorText= "--RX OK--";
      RxErrorExpected = ' ';
      RxErrorFound =  ' ';
    break;
  }
  console.log(ISODateString()+"----Cmd: "+String.fromCharCode(RxCmd)+"  Err: "+Err+" <"+RxErrorText+"> "+" Tot: "+rxErrors+" Expected: "+RxErrorExpected+" Found: "+RxErrorFound);
  RxPtrOut=0;				// flush circular queue
  RxPtrIn=0;
  RxPtrEnd=0;
  RxStatus=0; 
  RxChkSum=0;
  rxErrors ++;
  imuPort.flush();
};

var RxTime = Date.now(); //debug

/*-----------------------------------------------------------------------------*/
Parser = function ()
{// execute the received command
  var cmd = String.fromCharCode(RxCmd);
  
  /*debug
  var slotTime = Date.now()-RxTime;
  //console.log("--RX cmd: " + cmd+"  "+(slotTime));
  if(slotTime < 10)
    {
      console.log("***********************ERROR");
    };
  debug*/
  
  RxTime = Date.now(); //debug
  
  RxStatus = 0;
  
  switch (cmd)
  {
      case 'b': // details on speed, current and position OUT
          parser.b_dsNavParam();
          break;

      case 'T': // GPS time parameters OUT
          parser.T_GpsTime();
          break;

      case 'G': // GPS service parameters OUT
          parser.G_GpsService();
          break;

      case 'K': // GPS & IMU (DCM) parameters OUT
          parser.K_GpsPos();
          break;

     case 'L': // values coming from Low Level Supervisor OUT
          parser.L_LLS();
          break;

     default:
          RxError(3); //	error: not a known command
          break;
  }
};