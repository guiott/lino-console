// ============ data collected from all boards to High Level Supervisor

/* GPS values coming from UDB4 IMU from ID 41 binary SIRF message
 * latitude, longitude, altitude, speed over ground, course over ground, 
 * climb, Horizontal Dilution Of Precision, Horizontal Estimated Position Error
 * List of visible satellites, No. of visible satellites
 * Year, Month, Day UTC from satellites
 * Hour, Minute, Seconds, UTC, leap seconds corrected from satellites
*/
 GPS={lat:0,                            //in degrees (+ = North) x 10^7
      lon:0,                            //in degrees (+ = East) x 107
           alt:0, sog:0, cog:0, climb:0,//x 10^2
           hdop:0,                      //Horizontal Dilution of Precision x 5 
           ehpe:0,                      //x 10^2
           satIdList:0,//Bit map of SVs used in solution. Bit 0 = SV 1, Bit 31 = SV 32
           svs:0,
           year:0, month:0, day:0, hour:0, min:0, sec:0};
 
 //LAT={deg:0, min:0, sec:0, dir:' '};
 //LON={deg:0, min:0, sec:0, dir:' '};

/* dsNav values coming through UDB4
    PosXmes;    current X position coordinate
    PosYmes;    current Y position coordinate
    VelInt[4];  speed in mm/s as an integer for all the wheels
    ADCValue[4];64 sample average ADC (motor current) also for slave
 stasis_err;    number of times imu and wheels very different
 stasis_alarm;  signal too many stasis errors
*/
 dsNav={posXmes:0, posYmes:0, 
           velInt:[0,0,0,0], 
           ADCValue:[0,0,0,0], 
           stasisErr:0, stasisAlarm:0};

/* UDB4 raw data
 rmat[9] Direction Cosine Matrix
 udb_cpu_load IMU CPU load
 YawOffset offset of the current postion to north

  UDB4 IMU computed values
 YawMesAbs absolute value of measured orientation binary angle (process control) (Degx10 0-3599)
 YawMesRel measured orientation binary angle (process control) (Degx10 0-3599) rel. to startup position
 Pitch     computed from rmat[] rotation matrix
 Roll      computed from rmat[] rotation matrix
*/
 UDB4={yawRad:0, pitchRad:0, rollRad:0, 
       yawDeg:0, pitchDeg:0, rollDeg:0,
       yawRelDeg:0,
       rmat:[0,0,0,0,0,0,0,0,0],
       udb_cpu_load:0,
       YawOffset:0};

/* HLS -> UDB4 -> dsNav command values to dsNav motor controller through UDB4
 VelDes   mean desired speed mm/s. a value of 0X7FFF means total STOP
 YawDes   desired orientation angle (set point)(Degx10 0-3599)
 Light    headlights intensity
 hPwrOff  Power Off command from HLS to LLS
 OrientFlag change the dsNav orientation mode (direct or PID)
*/  
 DES={vel:0, 
      yaw:0,
      light:[0,0],
      hPwrOff:0,
      OrientFlag:0
     };

/* LLS -> HLS values coming from Low Level Supervisor
    BatV[]  Left and Right battery voltage level
    Temp[]  Left and Right hulls temperature
 	obst    Obstacles distances adjusted and RAW data
 lPwrOff Power Off command from LLS to HLS
*/
 LLS={batV:[0,0], 
      temp:[0,0],
      obst:[255,255,255,255,255,255,255,255,255,255,255],
      lPwrOff:0
      };

// ============================================================================


exports.loopB = function (joy)
{//sending loopback joysticks values for testing purposes
      
      GPS.lat=418588921;
      GPS.lon=125690952;
      GPS.alt=78;
      GPS.cog=123;
      GPS.sog=67;
      GPS.hdop=2.3;
      GPS.ehpe=1.8;
      GPS.svs=9;
      var d = new Date();
      GPS.year=d.getUTCFullYear();
      GPS.day=d.getUTCDate();
      GPS.month=d.getUTCMonth()+1;
      GPS.hour=d.getUTCHours();
      GPS.min=d.getUTCMinutes();
      GPS.sec=d.getUTCSeconds();
      UDB4.yawAbs = joy.RX * 1.8;
      UDB4.yawRel =  joy.RX * 1.8 - 45;
      UDB4.pitch = -joy.LY * 0.9;
      UDB4.roll = -joy.LX * 0.9;
      dsNav.ADCValue[0] = Math.abs(joy.RY * 14);
      dsNav.ADCValue[1] = Math.abs(joy.RY * 14);
      dsNav.ADCValue[2] = Math.abs(joy.RY * 14);
      dsNav.ADCValue[3] = Math.abs(joy.RY * 14);
      dsNav.velInt[0] = joy.RY * 14;
      dsNav.velInt[1] = joy.RY * 14;
      dsNav.velInt[2] = joy.RY * 14;
      dsNav.velInt[3] = joy.RY * 14;
      LLS.temp[0] = 35;
      LLS.temp[1] = 25;
      LLS.batV[0] = 50;
      LLS.batV[1] = 75;
};

exports.TX = function (client)
{//send values to client
    var Tx =
    {
      'lat': GPS.lat,
      'lon': GPS.lon, 
      'alt': GPS.alt,
      'sog': GPS.sog,
      'cog': GPS.cog,
      'climb': GPS.climb,
      'hdop': GPS.hdop,
      'ehpe': GPS.ehpe,
      'satIdList': GPS.satIdList,
      'svs': GPS.svs,
      'year': GPS.year,
      'month': GPS.month,
      'day': GPS.day,
      'hour': GPS.hour,
      'min': GPS.min,
      'sec': GPS.sec,
      'posXmes': dsNav.posXmes, 
      'posYmes': dsNav.posYmes,
      'velInt': dsNav.velInt, 
      'ADCValue': dsNav.ADCValue, 
      'stasisErr': dsNav.stasisErr,
      'stasisAlarm': dsNav.stasisAlarm,
      'yawAbs': UDB4.yawDeg,
      'yawRel': UDB4.yawRel,
      'pitch': UDB4.pitchDeg,
      'roll': UDB4.rollDeg,
      'batV': LLS.batV,
      'temp': LLS.temp,
      'lPwrOff': LLS.lPwrOff,
      'hPwrOff': DES.hPwrOff,
      'obstacle': LLS.obst // Sonar obstacle array
    };
    client.emit('RxEvent', JSON.stringify(Tx));
};